#THORChain

# 번개 빠른 분산 교환 프로토콜
devs@thorchain.org

2018 년 7 월 1 일

### 초록
> THORChain은 sub-second 블록 최종성을 달성하기 위해 pBFT 컨센서스를 사용하여 고도로 최적화 된 다중 체인입니다. 토큰은 이산 주소 공간을 가진 tokenChains라고하는 단일 체인으로 거래됩니다. 비잔틴 저항성 스케일링을 허용하기 위해 다중 세트 샤딩이 제안되었습니다. 기본 프로토콜은 프로토콜 수준에서 온 체인 거래 및 주문 일치를 용이하게하며 제한 및 시장 주문을 모두 지원합니다. 지속적인 유동성 풀은 모든 토큰 쌍에 대해 항상 유동성을 보장하며, 프로토콜의 초석 인 신뢰할 수없는 체인상의 가격 피드의 원천으로도 사용됩니다. 인센티브는 연쇄 유동성을 지속적으로 유치하기 위해 고안되었습니다. 온 - 체인 토큰 생성은 고정형 및 가변형 공급 토큰 모두에 대해 내장되어 있으며 감사 가능한 담보 형 ​​안정환의 잠재 성을 갖추고 있습니다. UTXO, 계좌 기반 및 계약 기반 cryptocurrencies를 사용하는 양방향 페그는 기존의 크립토 통화가 대부분 THORChain에서 원활하게 움직일 수있게합니다. 투명한 개발자 인센티브 전략을 통해 지갑 및 교환 개발자는 프로토콜 수준에서 자금을 지원받을 수 있으므로 활발한 개발자 커뮤니티가 권장됩니다. 강제 투표 및 2 차 폴링을 통한 온 - 체인 (on-chain) 거버넌스 및 스마트 업데이트는 THORChain이 논쟁적인 하드 포크 없이도 필요에 따라 확장 가능한 적응 형 및 반복적 플랫폼이라는 것을 보장합니다. THORChain은 플래시 네트워크와 호환되도록 제작되었습니다. 레이어 2 지불 채널 네트워크

## 개요

[소개] (# 소개)
- 중앙 집중식 및 지방 분권 교류
- THORChain 및 ASGARDEX

[THORChain 아키텍처] (# thorchain-architecture)
- 개요
- TokenChains
- MerkleChain
- 합의
- 검사기 세트
- 복수 검사기 세트

[온 체인 거버넌스] (체인 온 거버넌스)
- 개요
- 주요 측면

[Tokens] (# 토큰)
- 룬 특성
- 보상 및 방출 차단
- 수수료
- TokenChain
- 룬 세대
- THORChain Bridges

[지속적인 유동성 풀] (# 연속 유동성 풀)
- 유동성 해결
- CLPs
- CLP 트랜잭션
- 유동성 수수료
- 신뢰할 수없는 체인 내 가격 피드

[On-chain Trading] (체인 온 거래)
- 계정 유형
- 거래 유형
- 한도 및 시장 주문

[사용자 환경] (사용자 경험 # 명)
- 지갑
- 거래
- 교환
- 교환 및 월렛 자금 지원
- 크로스 토큰 거래
- On-Chain 초기 교환 오퍼링
- Validator 스테 킹

[기타 기능] (기타 # 가지 기능)
- THOR 체인 네임 서비스 (TNS)
- 계정 복구
- 다중 시그널 계정
- 현명한 계약
- 추가 On-Chain 명령
- StableCoins
- 토큰 바구니 & 인덱스
- 익명 성
- FIX 4.4 프로토콜

[결론] (# 결론)

[참고 문헌] (# 참조)


## 정의

항목 | 정의 |
| : --- : | : ------------ |
ASGARDEX | THORChain 기반의 분산 Exchange
| Bifröst Protocol | 다른 네트워크에 구축 된 브리지 (양방향 페그).
| CLP | 지속적인 유동성 풀
| DEX | 분산 된 Exchange
ECDSA | 타원 곡선 전자 서명 알고리즘
| ERC-20, NEP-5, QRC-20 | Ethereum, NEO, QTUM 토큰
| 플래시 네트워크 | 레이어 2 결제 채널 네트워크
| FIX4.4 프로토콜 | 외부 정보 교환 4.4 무역 데스크 프로토콜
| HFT | 고주파 거래
Mjölnir | 유동성 노드.
| RNG | 난수 생성
| RUNE | THORChain 기본 토큰, 룬 토큰, 룬, "RUNE"
| pBFT | 실용적인 비잔틴 결함 허용 오차
| THORChain의 룬 / 토큰 | 토큰
| TokenChain / RuneChain | 각 토큰에 대한 체인
| TPS | 초당 트랜잭션
| UTXO | 미사용 트랜잭션 출력
| VRF | Verifiably Random Function |

## 소개

### 중앙 집중식 및 지방 분권 교류

** 교환 **. cryptocurrency 경제의 가장 중요한 출현 중 하나는 암호화 교환입니다. 디지털 자산은 자체적으로 유용하지만 창조자, 소비자, 투자자 및 거래자가 공개적으로 자유롭게이 자산을 다른 사람에게 양도 할 수 있도록 교환이 필요합니다. 디지털 자산이 시장 균형 가격에 도달함에 따라 모든 시장 참여자들은 정부, 규제 기관 또는 물류 장벽으로부터의 간섭으로 인해 사용할 수 없거나 실제로 평형 상태에 있지 않은 시장을 정리함으로써 이익을 얻습니다.
벤처 캐피탈리스트, 서비스 제공 업체, 직원, 창립자 및 기타 회사 이해 관계자는 IPO 이전의 비밀 유지 또는 방해를받지 않는 자유로운 유동성으로 이익을 얻습니다. 이는 자산 지원, 서비스 지원 또는 인프라 지원 여부에 관계없이 토큰에 적용됩니다. 자산 지원 사례의 경우 암호 해독 교환을 통해 기본적으로 블록 체인에 있거나 조정자가 처리하는 조정 요구 사항으로 인해 현재 시간과 비용면에서 더 많은 비용이 드는 유가 증권 거래를 쉽게 수행 할 수 있습니다.
Cryptocurrency 교환은 사람들이 수행하는 각각의 개별 트랜잭션에 대해 선택한 cryptocurrency를 사용할 때 유연성을 증가시킵니다. 그들은 소비 수요를 포착하는 몇 가지 핵심 시장에 집중할 수 있습니다. 예를 들어 데이터 저장소를1 차 소비가 필요한 것은 Filecoin이나 Sia에 많은 부를 축적 할 수 있고, 선적화물에 크게 의존하는 다른 사람들은 Shipchain이나 VeChain에 부를 저장할 수 있습니다. 특수화 된 cryptocurrencies가 견인력을 얻음에 따라 사용자는 특정 토큰 생태계에서 자신의 부를 분류 할 수 있습니다. 그들은 이러한 생태계에 긍정적 인 거버넌스와 친 사회 활동에 대한 부의 부를 더하여 보상 할 수 있습니다. 따라서 모든 토큰 생태계가 서로 경쟁하여 사용자에게 최고의 경제를 제공해야합니다. 이 경쟁은 신속하고 안전하며 신뢰할 수있는 자산 이동을 가능케하는 교환의 확산으로 만 가능합니다. 마지막으로 거래소는 거래자가 장래의 시장 행동 예측을 통해 이익을 얻을 수 있도록합니다. 글로벌 자산이 소수의 기업에 점점 더 집중됨에 따라 시장의 미래를 예언하고 추가적인 자산을 얻는 데 필요한 자원도 함께 사용하게됩니다. cryptocurrency 시장이 새롭고 가볍게 규제되기 때문에 대규모 재취업자는 정확하고 수익성있는 가설을 세우는 평신도에 비해 압도적 인 이점이 적습니다. 숙련 된 거래자는 시장 이득을 분산시킬 수있는 주요 기관에 묶이지 않고 통찰력있는 분석에 대한 보상에 직접 참여할 수 있습니다. ** 지방 분권 **. 물론 위의 내용은 다른 권력의 원천 또한 분권화되어있는 경우에만 해당됩니다. 분권화의 목표 중 하나는 교환 자체입니다. 중앙 집중식 교환은 사용자에게 과도한 권한을 부여 할 수 있습니다. 이것은 그들이 cryptocurrency 매니아들이 평범한 세계에서 싫어하는 많은 퇴행 적 관행에 참여할 수있게 해줍니다. 일부는 설명이나 도움없이 사용자의 자금을 보유합니다. 분산 형 대안은 사용자가 언제나 자신의 자산에 대한 자기 주권을 유지할 수있게합니다. 일부 중앙 집중식 교환은 현지 법률로 인해 사용자, 통화 또는 거래를 금지합니다. 분산 형 대안은 국가 운영자가 제한을 가할 수있는 중앙 운영자가 없다. 공개 코드를 사용하는 분산 된 대안은 영구적 인 공개 보안 감사 및 공개적으로 변경되는 코드 변경의 이점을 누릴 수 있습니다. 모든 것이 평등하고, 분산 된 교환 (DEX)은 중앙 집중식 교환보다 크립토크 통화의 정신을 더 적절하게 포착합니다. 그러나 모든 것은 아직 동일하지 않습니다. 분산 형 교환기는 성공적으로 경쟁하기 위해 중앙 집중식 교환기로 기능 및 성능 패리티가 필요합니다. 가장 많이 사용되는 중앙 집중식 교환기 중 하나 인 [Binance] (https://www.binance.com)는 초당 백만 건 이상의 트랜잭션을 처리합니다. 널리 사용되는 분산 형 교환기 인 [Forkdelta] (https://forkdelta.github.io)는 정기적으로 분 단위의 트랜잭션을 처리합니다. 대중적인 중앙 교환소 인 Bittrex (https://www.bittrex.com)는 디자인 전문가와 사용하기 쉬운 UX에 의해 잘 정비 된 잘 디자인 된 UI를 가지고 있습니다. DEX 인 [Barterdex] (https://komodoplatform.com/decentralized-exchange/)는 둔한 UI를 가지고 있으며 UX에서 몇 가지 성가신 단계가 필요합니다. 중앙 암호화 방식 교환은 무수히 다양한 토큰 유형을 나열하는 것에 자부심을 가지고 있습니다. 대부분의 최신 DEX는 단일 암호 암호화 생태계 내에서 작동합니다 (예 : [Stellardex] (https://stellarterm.com)에서는 별, [Etherdelta] (https://etherdelta.com)에서는 ether). 하나의 프로토콜. 일부 제약 조건을 피하기 위해 일부 DEX는 분권화에 대한 부분적인 조치를 취하지 만 시스템의 주요 측면 (예 : 주문서 및 일치하는 엔진)을 중앙 집중화합니다. 이것은 좋은 시도이지만 이러한 서비스는 검열에 대한 저항을 제공하지 않으며 지방 분권화에 대한 약속을 이행하지 않습니다. 시장은 분산화의 핵심 교리에 부합하면서도 중앙 집중식 교환기가 설정 한 기능 및 성능 표준을 충족시키는 세계적인 수준의 교환 경험을 제공하는 분산 형 교환기가 필요합니다. 

### 사슬과 성가신 
** 사탄 **. Thorchain은 이러한 문제를 해결합니다. Thorchain은 10K TPS의 초기 성능과 1TPS의 목표를 통해 중앙 집중식 교환기와 동일한 트래픽을 처리 할 수 ​​있습니다. 토르 체인 (Thorchain)은 주문 일치 및 주문서 인구를 포함한 무역의 모든 측면을 분권화하여 검열에 대한 저항을 보장합니다. 대부분의 DEX는 일일 거래량이 1 천만 달러 미만이지만 Thorchain 재단은 Thorchain Foundation에서 직접 유동성으로 그 양의 몇 배를 시딩하게됩니다. 또한 Thorchain의 지속적인 유동성 풀 메커니즘 (Bancor에서 빌린 것)은 더 많은 유동성을 제공하는 사용자에게 수수료를 제공하여 더 많은 인센티브를 제공합니다. Thorchain의 cryptocurrency bridge를 사용하면 cryptocurrency 생태계 전반에서 트랜잭션을 기본적으로 지원할 수 있습니다. 사용자는 Thorchain DEX에서 직접 Bitcoin for Ether 또는 NEP-5 토큰에 대한 ERC-20 토큰을 교환 할 수 있습니다. 교량은 별도로 상세히 다루어집니다 .ASGARDEX (THORChain 위에 구축 될 첫 번째 DEX)는 유동성이 풍부하고 공개적으로 구입 가능한 주문서, 교량과 호환되는 크립토 통화 (cryptocurrencies)에 대한 전산화 토큰 (omni-token) 지원, 세계 정상급 UI 및 정제 된 UX. ASGARDEX는 주요한 pr을 해결합니다.보안이 보장되고 투명하며 검열에 견딜 수 있고 내결함성이있는 암호 교환 교환을 약속받을 수 있습니다. ## THORChain Architecture ### OverviewTHORChain은 사이드 체인 "TokenChains"와 마스터 "MerkleChain"으로 구성된 다중 블록 체인 프로토콜입니다. MerkleChain은 네트워크의 전체 상태를 추적하여 Merkle Tree의 최신 해시를 저장하여 이중 지출을 방지하고 네트워크 상태를 동기화합니다. 프로토콜의 모든 측면 체인은 Validator Set의 보안, 기술 또는 선호 사항에 대한 설명이없는 "일급 시민"입니다. TokenChains에는 토큰의 특성을 설명하고 해당 토큰에 대한 트랜잭션 만 추적하는 기원 계정이 있습니다. 각 TokenChain은 트랜잭션 mempools의 충돌을 허용하는 개별 주소 공간을 유지합니다. TokenChains는 Ethereum과 비슷한 방식으로 계정 기반입니다 (UTXO 기반 Bitcoin과 같이 사용되지 않은 트랜잭션이 추적되는 것과 반대). 넌 스는 각 계정의 최신 상태를 추적하여 이전의 모든 계정 상태를 무효화합니다. 생태계의 토큰은 룬 (Rune)이며 프로토콜의 생성 시점에 생성되며 모든 룬 트랜잭션은 첫 번째 사이드 체인 'T0'에서 추적됩니다. 룬은 생태계의 정착 통화이며 모든 체인 내 유동성 풀에 저장되어있어 고유합니다. 모든 사이드 체인의 기원 블록에는 Rune과 해당 토큰의 가격 비율을 정의하는 지속적인 유동성 풀 (CLP)이 있습니다. CLP에 대해서는이 백서의 뒷부분에서 자세히 설명합니다. 지금은 CLP가 룬 (Rune)으로 명명 된 거래를하고자하는 모든 사람에게 거래 상대방을 제공한다고 생각하십시오. 두 명의 사용자가 두 개의 비표준 토큰간에 거래하는 경우 트랜잭션이 완료되기 전에 토큰 중 하나가 자동으로 룬으로 변환됩니다. 

<img align="center" src="https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure1.png" width="350px" height="280px" />

_ 그림 1 : 각 토큰은 개별 TokenChain에서 추적됩니다. Genesis는 토큰 정보를 추적하고 체인상의 유동성을 유지합니다. _ 

### TokenChains

각 TokenChain에는 개별 주소 공간이 있습니다.

<img align="center" src="https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure2.png" width="350px" height="158px" />

_ 그림 2 : THORChain 주소 공간; Rune (T0)의 경우 여기._ 

접두사는 다른 모든 프로토콜과 주소 공간을 분리합니다. TokenIndex는 Rune이 'T0'이고, 첫 번째 체인상의 토큰이 'T1'등인 다른 온 체인 토큰과 토큰을 분리합니다. Separator는 (가변 길이 일 수있는) TokenIndex와 비공개 키의 SHA256 해시
그녀의 룬을위한 공개 주소 인`T0xAlice`를 가진 앨리스는 토큰이있는 다른 모든 TokenChain에도 주소가 일치하게됩니다. 그녀의 단일 개인 키는 모든 주소의 잠금을 해제합니다. Alice가 새로운 토큰을 보낸다면; 새 주소가 자동으로 생성됩니다.

```
T0xAlice -> Rune address for Alice
T1xAlice -> T1 address for Alice
T5xAlice -> T5 address for Alice
TnxAlice -> Tn address for Alice
```

여러 개의 체인에 충돌이없는 주소 공간은 다음과 같은 장점이 있습니다 : - 디스크리트 트랜잭션 각각의 토큰에 대해 개별적인 mem-pool을 가지고 있습니다. - 각 토큰에는 분명하고 뚜렷한 계보가 있습니다. - 각 

TokenChain은 네트워크에 대한 기본 기능을 포함하고 수행하는 기성 계정을 상속합니다. Tokenchains는 Thorchain 내부 또는 외부 토큰 (Bitcoin 또는 Ethereum과 같은) 내부의 토큰을 나타낼 수 있습니다. 이 토큰은 Thorchain 내에서 거래 될 수 있지만 Thorchain 브릿지에 저장된 실제 외부 토큰을 나타냅니다. 

ASGARDEX에서 'BTC'를 거래하는 UX는 사용자가 브리지를 선택하고 해당 브리지가 제어하는 지갑에 'BTC'를 전송하며 해당 토르 체인 지갑 비트 코인을 원하는 토털 체인의 BTC 트랜잭션에 대한 데이터 필드를 지정합니다 `tBTC`가 저장됩니다. 해당 'tBTC` 지갑 주소가없는 브리지로 전송 된 Bitcoin은 자동으로 되돌려 보내야합니다. 이러한 일이 발생하면 온 체인 트레이드가 발생할 수 있습니다. 'BTC'를 철회하기 위해 사용자는 다리와 'BTC'지갑을 지정한 다음 지갑에서 다리 지갑으로 'tBTC'이전을 시작합니다. 그런 다음 브리지는 'BTC'를 해당 BTC 지갑으로 이동시킵니다. 마찬가지로 'tBTC'는 올바른 데이터 필드없이 전송되고 형식이 반환됩니다. 


### MerkleChain
MerkleChain은 네트워크의 각 TokenChain에 대한 최신 트랜잭션을 해싱하고 merkelizing하여 네트워크 상태를 추적하고 동기화합니다. 이 메커니즘의 개요는 다음과 같습니다. 유효성 검사기 모음은 각 토큰 체인에서 Merkle Roots를 수집하고 Merkle Tree로 어셈블되며 각 TokenChain에 대한 블록 n에 대한 단일 Merkle Root로 해시됩니다. Token Merkle Roots는 다른 Merkle Tree로 수집되고 최종 Master Merkle Root가 생성됩니다. 그런 다음 이것은 Validator Set에 의해 MerkleChain 블록`n + 1 '에 삽입됩니다. Validator Set은 동시에 같은 Master Merkle Root를 블록`n + 1 '의 모든 tokenchain에 삽입합니다. MerkleChain은 또한 네트워크를 저장합니다TokenIndex 카운터와 같이 네트워크의 TokenChains를 지정하고 해독하는 광범위한 정보 ### ConsensusTHORChain은 비잔틴 결함 허용 상태 머신 복제 알고리즘 인 Tendermint를 구현합니다. 텐더 민트는 THORChain의 요구 사항을 만족시키기 위해 필요한 완성도, 성능 및 보안 성을 갖추고 있습니다. 텐더 믹트 (Tendermint)는 블록 체인 (blockchain)에 없어서는 안될 속성 인 즉석 최종성 (instant final)을 지원한다는 점에서 가장 유용합니다. 텐더 민트 (Tendermint)는 거래가 끝난 후 (예 : Bitcoin 및 Ethereum V1) 합의를 기다리지 않고 수퍼 컨센서스에 이미 도달 한 거래 만 커밋함으로써이 문제를 해결합니다. 따라서 Tendermint는 1 초 미만의 블록 시간을 지원하고 최대 1TPS까지 처리 할 수 ​​있습니다. 처음에는 THORChain에 대해 텐더 미드 성능이 충분하지만 100 만 TPS 이상의 중앙 집중식 교환으로 성능 패리티를 달성하는 최종 상태를 지원하는 수정이 필요할 것입니다. 이 성능을 달성하기 위해 THORChain은 다양한 샤딩 구현을 연구 및 구현해야합니다. ** Validator Set ** Tendermint는 전체 노드를 Validator로 사용하거나 제작자를 차단해야하며 각 Validator는 네트워크에서 가중치를 가져야합니다. 무게는 스테이 킹에 의해 결정되므로 텐더 민트는 상자에서 나온 스테이크 증명을 지원할 수 있습니다. THORChain의 첫 번째 구현에는 경매를 통해 사용 가능한 모든 유효성 검사기에서 가져온 단일 유효성 검사기 집합이 있습니다. 100 개의 가장 높은 측설 된 Validators가 Validator Set를 형성합니다. 유효성 검사기는 블록을 제안하고 동의하고 커밋합니다. Validator Set에 합류하기 위해서는 Validator가 가장 낮은 Validator보다 높은 지분을 가져야하며,이 프로세스를 통해 경제적 투자가 가장 많은 Validators가 네트워크를 안전하게 보호 할 수 있습니다. 스 테이킹 풀 (pooling)은 더 넓은 참여를 허용 할 수 있으며, 누구나 선택한 밸리데이터에 자신의 스테이크를 위임 할 수 있습니다. 유효성 검사기는 블록 보상에서 지급되며 보유한 지분과 관계없이 균등하게 지급됩니다. 대리인 보유자는 Validator의 전체 지분에 대해 비례하여 지급됩니다. 그래서 디자인과 자기 이익에 의해; 현재 지분이 가장 적은 Validator를 선택해야하지만 최상위 '100'에 있어야합니다. 이를 통해 프록시 보유자는 자신의 수익 잠재력이 가장 큰 지분을 분산 할 수 있으므로 결과적으로 소수 그룹이 Validator Set에 Validator 참여에 영향을 줄 수있는 매우 평평하고 경쟁적인 그룹 100을 보장합니다. <img align = "center"src ="https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure3.png"width = "350px"height = "304px"/> _ 그림 3 : 유효성 검사기 Set_An 프로토콜 불이익은 유효성 검사기가 네트워크에서 오작동하는 것을 방지하기 위해 필요합니다. 이것은 캐스퍼와 코스모스에서 심하게 연구되고 있습니다. 오작동은 이중 서명 블록 일 수도 있고 오프 라인이거나 온 체인 투표에 참여하지 않을 수도 있습니다. 유효성 검사기가 깎인 금액은 사건의 심각도에 따라 다르며 mainnet보다 먼저 on-chain 투표로 확정됩니다. 발기인이 대기중인 가장 높은 발기인보다 낮은 수준으로 내려지면 부정직 한 발기인이 퇴거되고 대기중인 발기인이 자동으로 발기인 설정에 참여합니다. 플랫 그룹, 경쟁의 심한 수준 및 부적절한 참여로 인해 경제적 손실이 발생하고 유효성 검사기 세트에서 퇴출 될 가능성으로 인해 공격기 검사기는 크게 낙담됩니다. 네트워크 보안은 THORChain에 대한 고려 사항입니다. EOS, CarbonVote 및 Steemit 투표 이벤트에서 볼 수 있듯이 역사적으로 체인 투표는 매우 낮은 투표율로 투표했습니다. 코스모스는 토큰의 인플레이션 율을 높이기 위해 토큰을 유효성 검사기 지분 (직접 또는 풀을 통해)으로 인센티브를 높이기 위해 해결하려고 시도하고 있습니다. 인플레이션은 7 %의 바닥과 20 %의 천장 사이에서 피벗하며 소유자에게 순환 공급 전체의 2/3의 바람직한 유대 상태에서 토큰을 채취하게합니다. 2/3 보세로, 네트워크는 최적의 안전성과 카르텔 및 plutocracy에 대한 저항력이 있습니다. 스테이크먼트 토큰이 이상적인 통화 속성을 상실한다는 단점이 있습니다. 따라서 코스모스는 이중 토큰 시스템을 도입했으며 보조 토큰은 거래 수수료를 지불하는 데 사용됩니다. 캐스퍼 V2가 이러한 메커니즘을 구현하고 콜레 이터를 위태롭게하면 Ether이 이상적인 통화 속성을 잃게 될지 여부는 알려지지 않았습니다. THORChain은 단순화를 위해 하나의 토큰을 채택 할 것이지만 메인 네트워킹까지 다른 Proof-of-Stake 체인의 실제 경제를 연구합니다. 보조 토큰이 구현되면 THORChain 온 체인 관리를 사용하여 수행 할 수 있습니다. ### Multiple Validator SetsTHORChain의 TPS 성능 메트릭은 대부분 하나의 Validator Set의 병목 현상에 따라 달라집니다. 유효성 검사기 집합에 유효성 검사기를 더 추가하면 성능이 향상되지 않고, 성능이 저하됩니다. 트랜잭션이 각 tokenChain에 분할되고 별도의 유효성 검사기 세트에 의해 유지 관리되는 다중 유효성 검사기 아키텍처를 조사하기 위해 THORChain의 설계가 주어진 기회가 있습니다. 각 tokenChain에서 트랜잭션을 sepa로 처리합니다.네트워크는 잠재적으로 무한대의 수준에서 수행 할 수 있습니다. 고유 한 주소 공간에 의해 각 TokenChain에 대한 별도의 mempools가 유지 관리되므로 THORChain에서 샤딩이 가능합니다. 이를 통해 보류중인 트랜잭션을 쉽게 분리 할 수 ​​있습니다. GasLimit은 THORChain에 대해 제한되어 네트워크가 포화 상태를 추적하고 분할 자 유효성 검사기 신호를 허용합니다. GasLimit이 상한선에 도달하면 ( '100'블록의 경우 '90 %'이상), 확장 요구 사항을 충족시키기 위해 별도의 검사기 세트가 형성됩니다. 이 경우, 다음으로 가장 높은 staked Validator가 선택되어 다른 Validator Set을 형성합니다. 기본 Validator Set (Validators`1-100`)는 가장 높은 가스 수요를 가진 TokenChain과 MerkleChain을 모든 Mempool에서 제거 할 것입니다. 두 번째 Validator Set (101-200)은 다른 모든 TokenChains를 유지합니다. 또한 2 차 유효성 검사기 세트가 GasLimit에 접근하면 가장 높은 TokenChain을 제외하고 모두 제거하고 3 차 TokenChain을 지정합니다. MerkleChain은 여러 개의 Validator Sets를 저장하고 추적합니다. Validator Set의 GasLimit이`100` 블록보다 길게`10 % '채도 이하로 감소하면 그 세트는 즉시 부모 세트로 해소됩니다. 상위 세트가 하위 이전에 해산되도록 신호를 보내면 마스터 VS가 모든 하위 VS를 다시 셔플하여 깨지지 않은 계층을 재설정하고 중단을 방지합니다. 이러한 방식으로 THORChain은 네트워크의 요구에 항상 부합 할 수 있도록 확장 할 수 있습니다. | | | : | | : --- : | : | | 1 |> 90 % 포화 | 유효성 검사기 세트 (VS1) 시작 신호 | 2 | 100 블록 | 3 | 101 블록 | 두 개의 체인 모두에서 <4 % <10 % 포화 | VS1 및 VS2 신호 병합 | 5 | 100 블록 | 6 | 101 블록 | VS2가 사용 중지되고 VS1이 두 체인을 모두 처리합니다. _Table : MerkleChain의 기능을 사용하고 subservient tokenChain MerkleRoots를 처리하여 마스터 VS가 분할 및 병합을 위해 주문하면 네트워크가 동기화되고 상호 운용 될 수 있습니다. Subservient tokenChains는 Master VS의 MerkleChain 및 RuneChain보다 덜 안전합니다. Validator는 자신의 mempools에 대한 지분이 적습니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure4.png"width = "350px"height = "231px"/> _ 그림 3 : 분리 된 Validator Sets_There는 네트워크 보안, 성능 및 추가 검증 및 개발이 필요한 여러 Validator Set의 특성과 관련하여 여러 가지 해결되지 않은 질문이 있지만 구현 방법에 대한 기본 사항은 여기에 설명되어 있습니다. 샤딩을 통한 다중 유효성 검사기 구현 계획에 대한 추가 연구는 별도의 문서에 있습니다 ## 윤리 경영에 대한 개요 # THORChain에 대한 체인 연맹은 "유효성 검사 신호"로 알려져 있습니다. 프로세스는 유효성 검사기에 의해 수행되며, 그 투표는 신호로 더 적절하게 언급됩니다. 검사기 신호는 검사기 신호화 백서에서 광범위하게 다룹니다. 모든 블록 제작자는 데이터 패킷으로 구조화 된 핵심 소프트웨어 및 합의 규칙의 변경을 제안 할 수 있습니다 :`{description, newCode, diffPatch}`다른 모든 유효성 검사기는 변경 사항을 수락하기 위해 투표하고 초 대다수 합의에 도달하면 업데이트 된 코드를 즉시 사용할 수 있습니다. 제안 및 동의 확인 도구는 컴파일 된 핵심 소프트웨어를 대기 모드로 실행하므로 승인되면 핵심 소프트웨어가 바로 다음 블록을 생성하기 위해 생방송됩니다. 공개 될 수있는 업데이트 유형은 본질적으로 무제한이며 다음과 같을 수 있습니다 : 초 대다수 임계 값과 같은 컨센서스 규칙 또는 (사내 거버넌스 자체와 관련된) 투표 규칙 컨센서스 알고리즘의 변경, 샤딩의 통합, 변경과 같은 프로토콜 아키텍처 블록 체인 구조 또는 서명 방식에 적용됩니다. 논의 된대로 고유 한 온 체인 명령을 사용하여 추가 거래 규칙을 프로토콜 수준에서 통합 할 수 있습니다. 공급 또는 인플레이션과 같은 토큰 구조 변경. 악용되거나 사용되지 않는 계정을 수정하는 등 상태를 변경합니다. ### 주요 측면 ** 경제적으로 시행 된 참여 **. 유권자 참여는 인 - 프로토콜 슬래싱 규칙에 의해 시행됩니다. 제안 된 업데이트 나 여론 조사에 투표하지 않으면 검사기의 지분이 삭감되어 투표를하는 다른 검사기에게 재분배됩니다. Validators가 커뮤니티 (또는 자신의 스테이크 풀)를 폴링하고 투표를하기 전에 위치를 차지할 수 있도록 n 블록의 유예 기간이 있습니다. ** 권한이 부여 된 소수 **. 2 차 폴링은 검사기의 스테이징 풀 내부에서 구현됩니다. Validator로 지분을 가진 각 회원은 각 지분이 하나의 전체 단위 인 지분에 비례하여 투표 할 수 있으며 후속 투표의 수가 증가합니다. 1 표는 1 토큰, 2 표는 3 토큰 (1 + 2), 3 표는 5 토큰 (1 + 2 + 3) 등이다.대주주가 투표 할 때 가질 수있는 편견을 제거하여 권위주의를 예방합니다. 또한 소수 민족이 자신의 투표가 의미 있고 대표된다는 것을 알도록 권한을 부여하고 권한을 부여합니다. 검사자는 투표소에서 투표권이없는 지지자를 대신하여 투표를 제출할 수 있지만 투표는 위와 같이 2 차로 가중치가 적용됩니다. 따라서 투표자가 아닌 투표자는 개인 투표가 자신의 토큰을 사용하여 대표 투표를 한 유효성 검사자보다 더 많은 비교 체중을 갖기 때문에 Validator의 최종 표를 쉽게 휘둘러야합니다. **적응성**. 모든 스테이커는 언제든지 다르게 신호를 내기 위해 투표를 변경할 수 있습니다. 서로 다른 유효성 검사기를 투표하기 위해 수영장을 스태킹하는 대표자는 본딩 기간에 구속되며 효과적으로 한 번만 전환 할 수 있습니다. 신중하게 설계된 온 - 칩 (on-chain) 거버넌스 솔루션 (자체적으로 업데이트 할 수 있음)은 THORChain이 포크리스자가 수정 원장이되어 향후 지속성이 높아질 가능성을 높입니다. ## Tokens ### 룬 특성 (Rune Characteristics) 룬은 생태계의 토큰이며 주소 공간 'T0'에 상주합니다. 초기 공급은 임의이지만 유한 수입니다. Rune의 사용법은 다음과 같습니다. Validator는 Validator Set의 일부로 Rune을 측설해야합니다. 스테이크가 끝나면 룬은 일정 기간 동안 보류 상태가되어 아무 것도 아닌 공격을 막습니다. 모든 네트워크 거래 수수료 (가스)는 룬에서 지급됩니다. 수수료는 생태계의 다른 요소에 의해 부과되는 거래 수수료, 거래 수수료, 교량 수수료 및 유동성 수수료 일 수 있습니다. 유동성은 항상 지속적인 유동성 풀의 룬 (Rune)에 의해 뒷받침됩니다. 그래서 룬 (Rune)은 생태계 정착 통화로서 기능한다. 플래시 네트워크 (Flash Network)는 룬 (Rune)이 유동성 허브에 합류하기 위해 유동성이 필요하며 수수료는 룬 (Rune)에서 지급됩니다. 레이어 1 밸리데이터 세트 및 레이어 2 유동성 노드에 대한 블록 보상은 룬에서 지급됩니다. ### Block Rewards와 EmissionTHORChain은 가격 경쟁력이있는 생태계를 창출하여 거래 수수료를 0으로 만드는 것을 목표로하는 예측 가능한 인플레이션 통화입니다. 인플레이션은 네트워크 보안, 다리 지원 제공 또는 레이어 1 또는 레이어 2 유동성 추가를 위해 지분을 제공하는 숨겨진 세금입니다. 현재 Ethereum, Bitcoin, EOS 및 Cosmos의 현재 물가 상승률을 고려할 때 '5 %'의 적절한 인플레이션이 제안됩니다. Rune은 가치 창고가 아닌 화폐 단위로 설계 되었기 때문에 Rune을 생태계에 꽂지 않고 보유하면 경제적으로 낙담하게됩니다. 그 밖의 모든 경우 룬은 지불금을 결제해야하는 한 유지됩니다. Block Rewards는 Validator Sets에 '50 %', Layer 2 유동성 노드에 '50 %'와 함께 발행됩니다. 유효성 검사기 세트의 각 유효성 검사기는 다음을받습니다. [rewards = rewardsTotal / (100 * Sets)] (https://latex.codecogs.com/gif.latex?rewards/%28100*Sets%29) 유동성 노드는 보상을 받게됩니다 유동성 및 신뢰성에 대한 보상을 제공하는 레이어 2 인센티브 계획에 따라 레이어 2가 메인 넷과 함께 시작되지 않으면 레이어 2 보상이 하드 코드되어 다시 파운데이션에 회부되어 교착 상태를 방지 할 수 있습니다. 그러면 유효성 검사자가 희석되거나 불이익을당하는 잘못된 인식으로 인해 레이어 2 인센티브 화 계획을 실행하지 않습니다. . ### FeesTHORChain은 각 TokenChain 블록에 대한 가스 요금 및 가스 한도의 개념을 유지합니다. GasLimit은 확장이 필요할 때 Validator Set 분할을 요구하도록 설계되었습니다. 가스 요금은 각 거래 유형별로 지불됩니다. 그 중 몇 가지 유형이 있습니다. 각 거래 유형은 프로토콜에서 하드 코딩되어 가스 견적을 낼 수 있습니다. 계층 1 유동성 수수료는 CLP (Continuous Liquidity Pool)를 사용할 때 수집되며 CLP의 유동성 기능입니다. CLP의 미납금이 높을수록 수수료가 부과되므로 더 많은 사용자가 수영장에 유동성을 제공하게됩니다. 유동성 심도를 추가하면 미끄러짐이 줄어들어 수집 된 수수료가 줄어 듭니다. 유동성 제조사는 수집 된 수수료를 포함한 모든 단계에서 유동성을 인출 할 수 있습니다. 자기 관심이있는 유동성 업체는 새로운 CLP를 구축하고, 수수료를 징수하고, CLP에서 무기한으로 수수료를 계속 받기 위해 초기 지분을 인출 할 가능성이 높습니다. 레이어 2 트레이딩 비용은 유동성 허브에 유동성을 제공하기 위해 유동성 노드에 지급됩니다. 각 허브 사용료는 가입 할 때 각 노드가 지정한 각 수수료의 평균입니다. 각 Rune Pair에 대해 여러 개의 허브가있을 수 있으므로 가격 경쟁 네트워크를 장려합니다. 여기에서 거래자는 평균 수수료가 가장 낮은 허브를 사용합니다. 노드는 원하는 허브에 자유롭게 가입하거나 자신 만의 허브를 만들 수 있습니다. 모든 유동성 노드는 Block Reward에서 지급되지만, 온라인 상으로 유동성과 시간으로 비중을 둡니다. [rewards = \ frac {rewardsTotal} {(100 * Sets)}] (http://quicklatex.com/cache3 /a0/ql_d86f3f504dbf143e5bf0a4dc5ed9a0a0_l3.png) 거래 수수료를 지불하고 유동성 허브에 대한 보상을 차단함으로써 노드는 액체, 온라인, 신뢰할 수있는 것으로 동기 부여되며 노드 수에는 제한이 없습니다. 따라서 네트워크는 많은 채널로 빠르게 분산됩니다. 이 내용은 플래시 네트워크에서보다 자세히 설명합니다.종이. ### TokenChainEach TokenChain은 1 차 룬 체인`T0`에서 특별한 창세 거래`GenTX`에서 생성됩니다. 생성 된 TokenChain은 다음 블록에서 창세기 계정 'GenAcc'로 시작됩니다. `GenACC`는 토큰의 특성에 대한 체인상의 사양과 토큰의 Continuous Liquidity Pool (나중에 정의 됨)을 호스팅하는 계정입니다. `GenTXs`는 룬 (Rune)에서 돈을 지불해야합니다. 새로운 토큰으로 네트워크를 스팸하는 데 효과적인 효과적인 sybil 조치입니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure5.png"width = "350px"height = "179px"/> _ 그림 5 : Token1 창세기 계정 'GenAcc`는 주문서, 지갑 및 거래소에 공개적으로 질의 및 표시 될 수있는 토큰에 대한 다음 정보를 저장합니다 : | Ticker | TKN1 | 표시 할 시커 || : --- | : --- | : --- | 이름 | 토큰 1 | 표시 할 이름 공급 | 100,000,000 | 총 공급 (100m) 십진수 | 18 | 십진수 리사브 | 1.0 | CLP의 부분 예비 (기본값은 1.0). 소유자 | 자기 | 자기라면; 기원 계정에 대한 개인 키가 없으므로 위의 세부 사항은 변경 불가능합니다. _ 테이블 : 고정 공급 토큰 _ 계좌 소유자가 SELF 인 경우 토큰 세부 정보는 변경 불가능하며 대부분의 디지털 자산에서 예상되는대로 변경할 수 없습니다. GenAcc는 해당 토큰 및 프로토콜 수준의 보안을 위해 쉽게 식별 할 수있는 연속 유동성 풀 (CLP)을 겸합니다. CLP는 다른 지갑에서 트랜잭션을 보내면 상호 작용할 수 있습니다. 이 경우 거래는 추가 논의 된 유동성 거래를 실행합니다. 외부 계정 소유자가 지정된 경우 해당 계정 소유자는 프록시 별 공급을 포함하여 토큰의 특성을 변경할 수 있습니다. 영구적 인 TokenIndex는 변경할 수 없으며 TokenChain을 식별합니다. 이러한 토큰은 계정 소유자가 토큰의 공급을 변경할 수 있으므로 다양한 공급 토큰으로 알려져 있습니다. 이것은 토큰 화 된 자산, 보안 토큰 및 단호한 토큰에 필요하며, 이로써 계정 소유자는 THORChain 논리가 아닌 외부 논리에 따라 토큰 특성을 변경할 수있는 단일 소유자 또는 다중 서명 소유자가 될 수 있습니다. 계정 소유자는 개인 키가없는 계정을 포함하여 다른 계정으로 GenAcc를 제어 할 수도 있습니다. 효과적으로 토큰을 고정 된 공급 불변 토큰으로 변환합니다. | 티커 | TKN1 | 표시 할 시커 || : --- | : --- | : --- | 이름 | 토큰 1 | 표시 할 이름 공급 | 100,000,000 | 총 공급 (100m) 십진수 | 18 | 십진수 리사브 | 1.0 | .Owner |`T1xa1b2c3d4e5f6` | 소유자는 자산 / 보안 / 고정 된 토큰에 필요한 변경 가능한 토큰 세부 사항을 허용하는 또 다른 주소가 될 수 있습니다 ._Table : 가변 공급 토큰 _ 최소 'GenTX` 개시 수수료는 다음과 같습니다. 토큰 스팸을 방지하기 위해`(100 * GasPrice) '로 설정해야하지만 런 어웨이 토큰 시작 비용은 중지해야합니다. ### Rune GenerationTHORChain은 동시에 체인의 CLP뿐 아니라 토큰의 전체 공급을 생성하는 고유 한 메커니즘을 허용합니다. 새로운 TokenChain을 생성하는 특별한 GenTX는 0이 아닌 양의 룬 (Rune)을 처리해야합니다. 이 0이 아닌 금액은 새로 생성 된 토큰과 함께 GenACC 내부의 룬을 트래핑하여 처음으로 CLP에 자금을 제공 할뿐만 아니라 GenTX 거래 수수료를 지불합니다. 이것은 토큰의 초기 가격을 설정합니다. 토큰 소유자는 특정 양의 룬 (Rune)을 처리하여 전체 토큰 금액을 양도합니다. 100 Rune이 GenTX이고 1 백만 개의 토큰이 생성 된 경우 (소수는 포함되지 않음) : ** Genesis Emission ** | TX in (Rune) | Rune Locked | Tokens Locked | Price (RUNE) | Tokens Emitted | : --- | : --- --- --- --- --- --- --- --- --- --- GenTX | (100 Rune) | 100 | 1,000,000 | 0.0001 ** 후속 CLP 트랜잭션 ** | TX in ( 룬 | 렁 잠금 | 토큰 잠김 | 가격 (룬) | 토큰 방출 : --- --- --- --- --- --- | --- --- --- --- | 90 | 190 | 100,000 | 0.001 | 900,00099 | 199 | 10,000 | 0.01 | 990,00099.9 | 199.9 | 1,000 | 0.1 | 999,00099.99 | 199.99 | 100 | 1.0999,90099.999 | 199.999 | 10 | 10 | 999,99099.9999 | 199.9999 | 1 | 100 | 999,999_Table : 새 토큰 생성 및 방출. 두 가지 거래가 있습니다. (1) GenTx 및 (2) 지정된 양의 토큰을 방출하는 후속 CLPTX. 하나의 요청으로 수행 될 수 있습니다 ._ GenAcc에 남아있는 잠긴 룬과 토큰을 완전히 방출 할 수 없으므로 토큰의 가격은 첫 번째 블록에서 설정됩니다. 초기 가격이나 유동성이 만족스럽지 않으면 가격을 수정하고 유동성을 추가하기 위해 특별한 일방 유동성 거래가 수행 될 수 있습니다. 개발자 커뮤니티는 사용자 경험을 이해하기 쉽게 토큰을 만들 수있는 소프트웨어를 개발할 것이라고 상상합니다. 다음은 하나의 클라이언트 측 순서로 토큰 생성을 수행하는 방법의 예입니다 : | Parameter | Field | Notes | : --- | : --- | : --- | 토큰 매개 변수 |`Ticker : TKN1, 이름 : 토큰, 공급 : 100m, 십진수 : 18, 소유자 : SELF}`| GenTX.CLP 매개 변수에 첨부 할 데이터 패킷 만들기 | {Reserve : 1.0, InitialPriCLPTX._Table에서 토큰의 초기 가격, 유동성 및 방출을 설정하고 계산합니다 : 새 토큰을 생성하는 매개 변수 _ ### THORChain BridgesTHORChain은 네이티브 십자가를가집니다. - UTXO, 계정 및 계약 기반 cryptocurrencies와의 호환성 이 핵심은 Layer 1 Bridge라고하는 트러스트없는 Two-Way-Pegs (2WP) 및 다중 서명 계정입니다. 핵심 유효성 검사기 세트 (`100` staked Validators)는 외부 체인에 대한 다중 서명 계정의 서명자이며 THORChain의 '2/3'서명 임계 값입니다. 이를 통해 Bitcoin, Ethereum (및 그 포크) 및 ERC-20 토큰을 THORChain 에코 시스템으로 원활하게 이동할 수 있습니다. 외부 코인은 Validator Set에 의해 서명 된 멀티 시그널 계정으로 이동됩니다. 관찰 된 최종 결과 후에 유효성 검사기 세트는 CLP를 통해 THORChain에서 새 토큰을 생성하는 서명 임계 값을 생성합니다. BLS 서명 임계 값은 서명의 임계 값 만 달성해야하므로 유효성 검사기 집합 조직에서 문제를 방지하는 데 사용됩니다. 생태계에서 동전을 이동 시키려면 그 반대가 발생합니다. BLS 서명 임계 값 이론은 DFinity에 의해 광범위하게 연구되었습니다. 시그니처 임계 값의 이점은 슈퍼 집합의 특정 임계 값 만 필요하며 슈퍼 집합의 특정 하위 집합은 필요하지 않습니다. 이는 누가 부분 집합의 일부가 될 수 있는지에 대한 유연성을 의미하며 유효성 검사기의 건강하고 경쟁적인 환경에서 빈번하게 발생할 수있는 유효성 검사기 집합을 떠났다가 다시 입력하는 유효성 검사기를 허용합니다. Cryptonote Monero 및 Loki와 같은 동전은 'm of n'다중 서명을 지원하지 않지만 'n n'또는 'n-1 of n'을 지원할 수 있습니다. 이 동전들을 지원하는 것이 가능하지만, Validator Set re-org에서 서명자 중 2 명 이상이 교체 될 위험이 있습니다. 축출 된 유효성 검사기가 온라인 상태를 유지하지 못하면 서명이 필요한 Cryptonote 동전은 THORChain에 무기한 잠겨 있습니다. 도난의 위험이 없습니다. 실제로 사용자는 'tXMR'에서 'tBTC'까지 거래하여 Bitcoin 브릿지에서 안전하게 퇴장 할 수 있으므로 이러한 불편 함을 낮은 중요성으로 보완 할 수 있습니다. 이것에 대한 완화 계획은 '1'유효성 검사기가 손실되면 즉시 유효성 검사기를 다시 셔플하는 것입니다. BiFrost 보고서에는 Thorchain의 교량 프로토콜 연구에 대한 추가 연구가 포함되어 있습니다 .. ## Continuous liquidity pools ### 유동성 풀기 분산 된 거래소는 유동성이 낮거나 유동성이 낮은 것으로 악명이 높습니다. 낮은 유동성 쌍에는 사용할 수 없습니다. 이는 또한 하위 계층 중앙 집중식 교환의 경우 일 수 있습니다. 유동성을 해결하는 것은 Bancor Network와 틀림없이 성공적인 노력에 큰 초점이었습니다. Bancor는 Ethereum에 설치된 스마트 계약서를 기반으로하는 스마트 토큰 및 커넥터를 사용하여 지속적인 유동성 개념을 도입했습니다. 토큰과 에테르는 보세가되고 보유 비율에 따라 가격이 책정되는 방식으로 현명한 계약서에 보관됩니다. 사용자는 이러한 현명한 계약에 토큰 또는 에테르를 보낼 수 있으며 다른 자산은 풀의 유동성 깊이를 고려한 슬립 인수 가격에 따라 배출됩니다. 결과적으로 이러한 유동성은 항상 이러한 토큰에 사용 가능합니다. THORChain은 2 가지 온 - 체인 유동성 전략을 통합합니다. Bancor의 지속적인 유동성 전략 인 CLP와 Komodo 블록 체인에서 채택한 체인상의 주문 도서 유동성 배분 (나중에 설명)을 채택했습니다. ### CLPs CLP는 틀림없이 THORChain의 가장 중요한 특징 중 하나입니다. 온 체인 유동성을 구축함으로써 생태계는 다음과 같은 이점을 얻습니다. - 생태계의 모든 토큰에 "항상 존재하는"신뢰없는 유동성을 제공합니다. - 유동성이 낮은 토큰에 대한 사용자 경험을 향상시킵니다. - 진보 된 거래 유형을 포함하여 생태계의 모든 측면을 강화하기 위해 신뢰할 수없는 체인 내 가격 피드의 소스로 작동합니다. - 차익 거래 기회를 생성하여 토큰 유동성을 추가로 늘립니다. - 사용자는 중앙 집중식 제 3 자에 의존하지 않고도 신뢰할 수없는 가격으로 토큰을 교환 할 수 있습니다. - 레이어 2 플래시 네트워크에 트러스티없는 가격 앵커를 제공하여 레이어 2 레벨에서 즉시 거래 할 수 있습니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure6.png"width = "350px"height = "253px"/> _ 그림 6 : CLP는 기성 계정입니다. _ ### CLP Transactions 'GenAcc'는 생성 된 토큰의 전체 공급과 룬 모두를 잠긴 유동성으로 유지하면서 각 TokenChain에 대한 CLP입니다. 계정 소유자는 토큰을 이동할 수 없습니다. 그들은`GenAcc` on-chain 명령과 만 상호 작용할 수 있습니다. 다음과 같은 6 가지 유효한 트랜잭션 유형이 있습니다. ** Rune In **. 누구나`GenAcc`에 룬을 보낼 수 있습니다. 'GenAcc'는 발신자의 TKN1 주소 ** TKN1 **에 보낸 'TKN1'(수수료 제외)을 내 보냅니다. 누구든지 'GenAcc'에 특정 토큰을 보낼 수 있습니다. `GenAcc`는 송신자의 룬 주소로 보내진 룬 (마이너스 수수료)을 방출합니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORCha그림 7 : CLP 트랜잭션 _ ** Rune LiquidityTx ** 누구나 'GenAcc'의 잠긴 유동성에 룬을 추가 할 수 있으며 'TKN1'은 없습니다. `발급됩니다. 이것은 송금인의 주소와 비례 유동성 비용을 추적하고 지불하기 위해 보낸 잔액을 등록하는 특별 거래입니다. ** TKN1 LiquidityTx ** 누구나 잠긴 유동성에 TKN1을 추가 할 수 있습니다. GenAcc 및 Rune은 발송되지 않으며, 발송자의 주소와 잔액은 유동성 비용 지불을 위해 등록됩니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/ 그림 8 : CLP에 유동성 추가 _ ** Rune LiquidityWithdrawTx ** CLP에 유동성을 추가 한 사람은 누구나 철수 할 수 있습니다. 초기 유동성 및 벌금의 최대 한도까지 ** TKN1 LiquidityWithdrawTx ** 또한 누구나 최대 토큰 1 유동성을 철회 할 수 있습니다. <i mg width = "350px"height = "209px"/> _ 그림 9 : Rune FeeWithdrawTx. CLP에 유동성을 추가 한 사람은 획득 한 금액을 인출 할 수 있습니다 ._ ** TKN1 FeeWithdrawTx **. 다시 말하면, 누구나 얻은 수수료를 인출 할 수 있습니다. 중요한 것은 잠긴 유동성은 내부 가격으로 만 토큰을 방출한다는 것입니다. 잠금 'RUNE : TKN1'비율에 의해 추론됩니다. `10 RUNE`이`1000 TKN1`과 함께 잠겨 있으면; `1 TKN1`의 가격은`0.01 RUNE`이며이 내부 가격으로 토큰이 배출됩니다. 배출량이 배출 후 토큰의 가격 인 미끄러짐의 요인은 다음 방정식에 의해 결정됩니다 :! [tokensEmitted = tokens * ((1+ \ frac {txRUNE} {RUNE}) ^ {ReserveRatio} -1) ] (https://latex.codecogs.com/gif.latex?tokensEmitted%3Dtokens*%28%281&plus;%5Cfrac%7BtxRUNE%7D%7BRUNE%7D%29%5E%7BReserveRatio%7D-1%29) 예약 비율 큰 슬립 률을 방지하기 위해 '100 %'보다 낮게 조정할 수 있으며 분수 준비금과 유사합니다. ### 유동성 수수료 유동성 수수료는 미끄러짐의 함수입니다. Rune 또는 Token을 방출하는 거래에서 가격이 변경되는 비율. 모든 트랜잭션 (아무리 작아도 상관 없음)은 잠겨있는 룬과 토큰 간의 비율을 변경하므로 비율의 후속 변경은 새로운 가격을 정의하므로 항상 슬립이 발생합니다. 수수료를 전표와 결합하여 더 많은 관심을 가진 사용자가 가장 필요한 CLP (높은 볼륨 및 낮은 유동성 CLP)에 유동성을 추가하도록 권장하려면 다음과 같이 수수료가 지급됩니다. [0.1 * slip * transactionSize] (https : // latex.codecogs.com/gif.latex?%5Clarge%200.1*slip*transactionSize) | 유동성 심도 | 거래 | 전표 | 유동성 수수료 | : --- | : --- | : --- | : --- | 1m Rune | 100 Rune | 0.01 % | 0.001 Rune 100,000 Rune | 1000 Rune | 1 % | 1 Rune1000 Rune | 500 Rune | 50 % | 25 Rune_Table : 유동성 요금 예시 _ ### 신뢰할 수없는 On-chain Price Feeds ** On- 체인 Arbitrage **. GenAcc와의 모든 상호 작용은 전표 내부 가격으로 반대 쌍을 방출합니다. 배출량이 많아 미끄러짐으로 인해 GenAcc 가격이 공정한 시장 가격에서 떨어질 수 있습니다. 이 경우, 자기 관심있는 중개인은 역 거래를 수행하여 즉시 가격을 정정합니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure10.png"width = "350px"height = "294px"/> _ 그림 10 : On-chain Arbitrage _ ** Price Oracle **. GenAcc의 토큰 가격은 항상 공정한 시장 가격이어야하며, 그렇지 않으면 자기 관심이있는 중재자가 조치를 취해야합니다. 대규모 가격 변동 이후에는 지연이있을 수 있지만 가격 변동이 크면 더 많은 유동성을 확보함으로써 자체 조정되는 대규모 유동성 수수료가 발생합니다. 따라서 THORChain 네트워크는 GenAcc 가격 정책에 기반한 생태계 전반에 걸쳐 신뢰할 수없는 토큰 가격을 적용 할 수 있습니다. Trustless Token 가격 책정은 다음과 같은 방법으로 프로토콜의 향후 버전에서 채택 될 수 있습니다. - 마진 거래 및 손실 중지 / 이익 획득과 같은 고급 주문 유형 촉진. - THORDApps 전반에서 토큰 가격에 대한 고급 dApp 기능을 사용할 수 있습니다 .- 공정한 시장 가격을 Layer 2 지불 네트워크로 전송하여 지원되는 자산에서 즉각적인 거래를 용이하게합니다. ** 가격 조작 **. 현존하는 경제로 인해 가격 조작의 비용은 THORChain에서 높습니다. 조작을 유치 할 가능성이 가장 높은 CLP가 가장 많이 사용되는 쌍이지만 조작 방법으로 조작자를 즉시 ​​체인 차익 거래 및 높은 유동성 비용에 노출시킵니다. CLP에서의 지속적인 조작은 CLP 전체의 볼륨을 증가 시켜서 자기 관심 유동성 보유자가 보유한 유동성 금액을 증가시켜 장기적으로 조작 효과를 감소시킵니다. ## On-chain Trading ### Account TypesTHORChain은 프로토콜 수준에서 온 체인 거래를 통합하여 원하는 거래 경험의 모든 측면을 충족시킵니다. THORChain은 UTXO 모델에 유연성을 제공하는 계정 기반 아키텍처를 사용합니다. 생태계에는 세 가지 계정 유형이 있습니다.d : 적절한 네이티브 온 체인 명령 : ** 월렛 계정 **. 월렛 계정의 특징은 다음과 같습니다.```- 계정 소유자 만 양도 할 수있는 잔액을 저장하십시오. ```잔액은 고유 한 넌스로 업데이트되고 나중의 넌스가 발행되면 낡은 잔액은 무효화됩니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure11.png"width = "350px"height = "144px"/> _ 그림 11 : THORChain Wallet for Rune (T0). Alice의 공개 주소는 [aaa ... aaa] _ ** Trading Account **입니다. 거래 계정에는 다음과 같은 특징이 있습니다. "-`- 계좌 소유자 - 유효한 입국 거래이며, 거래 집행을 수행 한 후에 만. - 가격을 저장하십시오. ``! [Trade = Balance * Price] (https://latex.codecogs.com/gif.latex?Trade%3DBalance*Price)````만기 시간을 상점에 저장하십시오. 호스트 비용을 저장하십시오. 사용자 대면 클라이언트는 선택적 요금을 추가 할 수 있습니다 .- 호스트 비용을 전송할 호스트 주소를 저장하십시오. - nonce를 저장합니다 .``` <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure12.png"width = "350px"height = "215px"/> _ 그림 12 : Rune (T0)에 대한 THORChain 거래 계정. 쌍 (T1) [aaa .... aaa]에 대한 Alice의 공용 주소는 자동으로 삽입되지만. ** CLP 계정 **을 지정할 수 있습니다. CLP는 각 토큰의 기원 계정에있는 특별 계정입니다 .Chain :```- 수수료를 징수 할 스테이커 (주소 및 약정액) 배열을 저장합니다 .- Rune 및 Token의 매장 잔액 .- Rune 및 Token의 매장 비용 .- 스토어 토큰 데이터 .- CLP 데이터 저장. - nonce를 저장합니다 .``` <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure13.png"width = "350px"height = "212px"/> _ 그림 13 : TKN1 (T1)의 THORChain CLP 계정 ._ ### 트랜잭션 유형 THORChain은 계정과 함께 트랜잭션 및 거래를 다루는 고유 한 트랜잭션 유형을 추가합니다. 이것은 각 거래마다 계산을 수행하고 상태를 저장하기 위해 계정 넌스를 업데이트하는 네이티브 온 체인 명령으로 실행됩니다. ** TX **. 수령인의 지갑에 잔액을 보냅니다. CLP로 보내지는 경우 해당 토큰이 보낸 사람의 토큰 지갑으로 되돌려 보내집니다. ```- Rune 또는 TKN을 전송하십시오. 받는 사람에게 필요한 지갑이 없으면 동일한 publicAddress를 사용하여 만듭니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain /Images/figure14.png "width ="350px "height ="160px "/> _ 그림 14 : 단일 체인에서 Bob에게 지불하는 앨리스. <img align ="center "src ="https://github.com/thorchain /Resources/blob/master/Whitepapers/THORChain/Images/figure15.png "width ="350px "height ="255px "/> _ 그림 15 : Bob을 체인을 통해 지불하는 앨리스. Alice는 Tx (bob) 또는 T1x (bob) 또는 T2x (bob)로 지불 할 수 있습니다. 하지만 균형은 T1x (보우)에서만 업데이트되었습니다. <width = ""= " 350px "height ="226px "/> _ 그림 16 : T0과 함께 TKN1 CLP와 상호 작용하는 앨리스. 그녀는 TKN1 ._ ** LiqTX **를받습니다. 유동성을 추가하기 위해 CLP에 균형을 보냅니다. 벌금을 징수하기 위해 송금인의 주소가 추가됩니다.``송금 룬 또는 TKN. ```잘못된 TKN이 전송되면 일치하는 토큰 CLP로 보내집니다. 이것은 바람직하지 않지만 쉽게 회복 될 수 있습니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure17.png"width = "350px"height = "243px"/> _ 그림 17 : 앨리스가 CLP1에 유동성을 추가했습니다. ** LiqWdTX **. CLP에서 유동성을 철회하십시오. ```- CLP에서 인출하라. ```서명이 스테이 커스 배열과 일치하면, 모든 유동성은 수입 수수료를 포함하여 발송인 주소로 배출됩니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure18.png"width = "350px"height = "246px"/> _ 그림 18 : 앨리스가 유동성 + 수수료를 인출했습니다 ._ ** FeeWdTX **. CLP에서 수수료를 인출하십시오. ```- 계정에 WithdrawFees 전화. ```서명이 일치하면 모든 요금이 발신자의 주소로 전송됩니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure19.png"width = "350px"height = "247px"/> _ 그림 19 : Alice가 그녀의 수업료를 인출합니다 ._ ** GenTX **. Genesis Transaction은 새로운 Token과 TokenChain을 만드는 데 사용됩니다 .``-Transfer RUNE.- Ticker와 Name을 설정하십시오 .- Set Supply. 변수 공급에 0을 남겨 둡니다 .- 십진수 설정 (기본값 18) - 예약 비율 설정 .- 계정 소유자를 설정합니다. 기본값은 자체입니다. "width ="350px "height ="184px "/"<img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure20.png" > _ 그림 : Alice가 Token1 TokenChain을 만듭니다. ** ** TradeTx **. 계정 거래는 거래 계정을 만드는 데 사용됩니다. ```- Rune 또는 TKN을 전송하십시오. - 가격 설정. Rune 또는 TKN.- Set Expiry (블록 단위). - 대상 계정을 설정하십시오 (기본값은 Alice의 토큰 주소 임). - 호스트 비용을 설정하십시오. 선택 과목. - 호스트 계정 설정. 선택 과목. ```<img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure21.png"width = "350px"height = "185px"/> _ 그림 : 앨리스 설정 `T0`에 대한 T1 판매 주문 _ ** WalletTx **. 계정 거래는 거래 계정을 월렛 계정으로 반환하는 데 사용됩니다. ```- Rune 또는 TKN을 전송하십시오. "width ="350px "height ="232px "/>"<img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure22.png" > _ 그림 : 그녀의 거래를 취소 한 앨리스 ._ ** TradeSolicitTx **. 무역 거래는 교역 룬 또는 TKN을 요구하는 데 사용됩니다 .- 가격을 정하십시오. 채울 희망 가격. - 제한 설정. 허용되는 가격에서 가장 멀리 벗어남. 시장 주문은 공란으로 남겨 둡니다. - 만료를 설정합니다 (블록 단위). 주문이 즉시 채워지지 않고 WalletTX가되는 경우에 사용됩니다. - 호스트 비용 설정. 선택 과목. - 호스트 계정 설정. 선택 .``` <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure23.png"width = "350px"height = "232px "/> _ 그림 : 앨리스의 T1 판매 주문을 사는 밥. 거래는 체인을 통해 'TO'에서 'T1'_ ** TradeExecuteTx **로 전송됩니다. TradeSolicitTx의 성공적인 결과. "- TKN을 매수 대상 계정으로 이전하십시오. - 여분의 Rune을 매수인 계좌로 환불하십시오 .- Rune을 판매 파티로 이전하십시오. - 업데이트 nonces.`` <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure24.png"width = "350px"height = "269px"/> _ 그림 : Bob은 Alice의 T1 판매 주문을 구입하고 추가 금액을 환불합니다. 앨리스는 룬을 얻습니다. _ ### 한도 및 시장 주문 ** 환불 **. 거래 수수료는 비 결정적이며 미리 알려지지 않을 수 있으므로 주문에 대한 최종 잔액은 거래 금액이 목표 주문량을 초과하면 "먼지"또는 초과 금액을 생성 할 수 있습니다. 환불 개념이 도입되었습니다. 이 환불은 환급 대신 릴레이를 통해 시장 주문 및 고급 거래와 같은 다른 거래 유형을 지원하는 유용한 메커니즘이됩니다. 한 주문에서 다른 주문으로 환불을 중계하는 것은 이전 충원에 의존하는 추가적인 결과적 거래를 생성하기 때문에 비효율적 인 것으로 간주 될 수 있지만 이점은 두 가지입니다. 첫 번째는 상인이 명시된 만료일 이전에 의도 한대로 처형 될 것이라는 것을 알고 거래를 "해고 잊을"수 있습니다. 두 번째로는 거래가 차단 공격에 취약 할 수있는 고객 소프트웨어를 대신하여 상인의 명령을 분할하지 않기 때문에 트레이드가 트러스트가없는 상태로 유지된다는 것입니다. 궁극적으로 여러 사용자 대신 하나의 사용자 대결로 거래를 수행 할 수 있으므로 사용자 경험이 향상됩니다. ** 주문 제한 **. 상인은 가격 한도 내에서 미결 주문에 대해 전체 잔액을 사용하고자합니다. 그들은 시작 가격뿐만 아니라 한도를 지정하고 주문이 만료되기 전에 해당 범위 내의 모든 미결 주문을 수집합니다. 이 메커니즘은 모든 주문이 이행 될 때까지 환불을 한 주문에서 다른 주문으로 중계하는 것입니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure25.png"width = "350px"height = "341px"/> _ 그림 : Bob이 제한 주문을 내립니다 ._ ** 시장 주문 **. 상인은 이용 가능한 모든 시장 가격으로 거래를 정리하기를 원할 수 있습니다. 이는 모든 주문이 완료 될 때까지 환불을 한 주문에서 다른 주문으로 중계하는 방식으로 수행됩니다. <width = "350px"height = "340px"/> _ 그림 : <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure26.png" Bob이 시장 주문을 내립니다 ._ ## 사용자 환경 ### 월렛 다음은 THORChain 기반 지갑 및 교환과 상호 작용 한 사용자 경험입니다. ** 월렛 인스턴스화 **. 사용자는 개인 / 공개 키 쌍을 생성하는 데 사용되는 오프라인 엔트로피 형식을 생성하여 새 지갑을 만듭니다. 이러한 키 쌍은 시드 단어 (BIP39), 키 저장소 또는 기억에 남는 두뇌 지갑으로 표현되고 보호 될 수 있습니다. FairLayer가 제안한 혁신 기술은 [이메일 + 비밀번호]를 고유하고 기억에 남을만한 휴대용 기기로 사용하기 때문에 엔트로피 소스로 사용됩니다. 단일 개인 키가 모든 사용자의 토큰 주소 (각 tokenChain에 하나씩)를 제어합니다. 월렛은 사용자가 동일한 엔트로피에서 n 개의 개인 / 공개 키 쌍을 생성 할 수있게하는 계층 적 결정 성 키 생성을 지원할 수 있습니다. ** 자산 유지 **. 모든 사용자 자산은 단일 지갑 인터페이스에서 볼 수 있습니다. GenAccounts에서 자산 세부 정보 (이름, 티커)를 신뢰할 수없이 쿼리 할 수 ​​있지만 CLP에서는 자산 가격을 쿼리 할 수 ​​있습니다. 또한 토큰 화 된 자산 (토큰 화 된 Bitcoin)에 대한 GenAccounts에서 브리지 계정을 쿼리 할 수 ​​있으므로 사용자가 외부 자산을 쉽게 생태계로 보낼 수 있습니다. ### 거래 ** CLP 거래 **. 사용자는 각 자산에 대한 CLP로 간단히 전송하여 지갑 내부에서 자산을 교환 할 수 있습니다. 가격은 예상되는 유동성 수수료와 함께 미리 표시됩니다. 공공 주문서 대신 CLP를 거래하는 이점은 투명한 수수료와 신뢰할 수없는 가격으로 즉시 스왑을 수행 할 수 있다는 것입니다.** 무역업 **. 사용자는 THORChain을 기반으로하는 분산 형 교환기에 키 쌍 또는 엔트로피를 가져올 수 있습니다. 그들은 공공 거래를 위해 모든 자산에 즉시 액세스 할 수 있습니다. ** 주문 생성 및 업데이트 **. 사용자는 Rune 또는 다른 토큰을 거래 계정으로 원활하게 이동하고 공개 구매 또는 판매 주문 (측면에 따라 다름)을 생성 할 수 있습니다. 주문은 언제든지 업데이트 할 수 있습니다. 월렛 또는 Exchange 프런트 엔드에서 수행되는 경우 개발자는 개발 수익에 선택적 요금을 부과 할 수 있습니다. 이 수수료는 공개되어 가격 경쟁을 유도합니다. ** 대형 주문 **. 거래자와 개발자는 대규모 주문을 완료하기위한 두 가지 옵션을 제공합니다. 거래자는 수동으로 자산을 분할하고 개별 주문을 선택하여 각각의 개별 주문에 소량의 자산을 보내 거래를 완료 할 수 있습니다. 개발자는 거래자를위한 주문을 분할하고 이러한 거래를 여러 주문에 보내는 클라이언트 측 소프트웨어를 만들 수도 있지만 이는 바람직하지 않습니다. ### ExchangesTraders는 현재 교류에 경험과 기능에 친숙한 교환 인터페이스에 액세스 할 수 있습니다. 모든 거래소는 동일한 주문서와 자산에 액세스하므로 모두 유동성을 공유합니다. ASGARDEX 교환은 mainnet을 위해 시작할 교환의 하나이지만 오픈 소스이며 쉽게 갈라질 수 있습니다. 이를 통해 개발자는 폐쇄 형 해자를 만드는 대신 지속적으로 혁신을 추진할 수 있습니다. ** 거래보기 **. 주문이 제공되면 블록 탐색기는 거래 계좌를 색인하고 공개 주문서에 표시 할 수 있습니다. 무역 측면은 항상 RUNE와 쌍을 이룹니다. 그러나 TKN : 지정된 경우 TKN 시장도 이용할 수 있습니다. 이 경우, 쌍은 기본 TokenIndex 각각에 대해 순서가 지정됩니다. 다음은 클라이언트 측 교환기에 표시되며 모든 클라이언트 측 인터페이스에 표시 될 수 있습니다. - 유동성 깊이 .- 촛대 및 볼륨 차트. - 이전 폐쇄 거래 .- CLP 계정 - 토큰 정보 - 브리지 계정 <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure27.png" width = "350px"height = "299px"/> _ 그림 : 거래를 읽고 표시합니다. ** 거래 **. 거래자는 프로토콜의 모든 기능에 액세스하여 자산에 대한 거래를 수행하고 언제든지 퇴장 할 수 있습니다. 개인 키는 클라이언트 측에서 보유되고 서명은 하드웨어 지갑에서 쿼리 할 수 ​​있습니다. ### 교환 및 월렛 자금 지원 교환 및 월렛에는 투명한 호스팅 수수료 및 계정을 각 AccountTX에 삽입 할 수있는 클라이언트 측 액세스 권한이 있습니다. 매 거래가 이루어지면 (제조사, 수취인, CLP 거래) 즉시 수수료가 호스트 계정으로 지급됩니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure28.png"width = "350px"height = "241px"/> _ 그림 : Exchange는 제조사 수수료를 삽입합니다. 이것은 THORChain 프로토콜을 사용하는 교환 및 지갑에서 탁월한 사용자 경험을 개발할 수 있도록 지원합니다. 가격 정책은 각 월렛 및 Exchange에서 발생하는 거래 수수료 만 수집하므로 자연스럽게 좋은 앱을 지원합니다. 요금 체계는 가격 경쟁과 공개이기 때문에 사용자가 최상의 요금을받을 수 있습니다. ### 크로스 토큰 거래 ** 사용자 **. Rune은 THORChain의 결제 통화이며 해당 CLP의 모든 토큰과 쌍을 이룹니다 (CLP가 작성되지 않은 THORChain에 토큰이 존재할 수 없음). 'T1'에서 'T2'와 같이 하나의 토큰에서 다른 토큰으로 교환하고자하는 사용자는 'T1 : T2'와 일치하는 CLP를 사용할 수 없습니다. 대신 Rune을 사용하여 해결하는 두 가지 트랜잭션을 수행 할 수 있습니다. `T1 : 룬 : T2`. `T1 : Rune`과`T2 : Rune CLP`를 사용합니다. 이 경우 방출 된 Rune은 즉시 다음 CLP로 재 라우트됩니다. 사용자는 두 가격이 모두 신뢰할 수없고 공정한 시장 가격임을 나타낼 수 있습니다. 수수료는 또한 투명하고 미리 알려질 수 있으며, 전체 거래가 완료 되려면 '2'블록이 필요합니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure29.png"width = "350px"height = "254px"/> _ 그림 : 두 CLP를 통한 라우팅 _ ** ** Traders For **. 위에서 설명한 메커니즘을 사용하면 모든 토큰이 서로 유동성을 갖게됩니다. 이것은 거래자의 요구에 충분할 수 있지만 고급 상인은 'tBTC : tETH'와 같이 하나의 토큰에서 다른 토큰으로 직접 주문 도서 시장을 선호 할 수 있습니다. 이것은 사용자가 주문 생성시 Rune에없는 쌍을 지정하여 작성하는 것입니다. THORChain 주문 도서 탐색기는 THORChain을 위해 구축 된 DEX에서 주문을 수집하고 적절하게 쌍을 이룹니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure30.png"width = "350px"height = "208px"/> 그림 : T1 : T2 판매 주문은 Rune 'T0` *과 짝을 이루지 않습니다. ### On-chain 초기 교환 오퍼링 THORChain에는 네이티브 온 체인 IEO를 지원하는 모든 메커니즘이 있습니다. 계약 기반 토큰 대신 이점은 토큰 표준이 변경 가능하고 감사 가능하며 백도어를 구축 할 수 없다는 것입니다. 또한 토큰은 imm와 즉각적인 유동성을 얻을 수 있습니다.ediate 시장. 마지막으로, 사용자는 가로 채기 공격을 최소화하는 지갑에서 직접 참여할 수 있습니다. 다음은 모든 팀이 자체 암호화 자산을 생성하는 프로세스입니다. - TokenChain은 토큰 세부 사항으로 작성됩니다. - 프로젝트 팀은 자신의 계좌로 토큰을 발행합니다 : 유동성이 생성되고 가격 책정이 설정됩니다. - 그 다음 프로젝트는 다수의 대형 공개 판매 주문을 만듭니다 (다른 가격 포인트 "보너스"가있을 수 있음 - 참여자가 각 판매 주문에 룬을 보냅니다.) 프로젝트는 또한 룬이 아닌 토큰 (예 : 'tBTC'또는 `tETH`) - 기여자들은 지갑에 새로운 토큰을 즉시받습니다. 이것은 새로운 세대의 액체, 감사 가능 및 트러스트없는 암호 매커니즘을 알려줍니다. ### Validator Staking 프로토콜의 핵심 부분은 Validators 스테이크 또는 "bond"Rune to 유효성 검사기 세트의 100 개에 속하며 규칙을 삭제하는 것에 동의해야합니다. 경제적 인 비용 절감으로 프로토콜의 보안을 정의합니다. 합의에 대한 67 %의 요구 사항으로 전체 프로토콜의 보안은 다음과 같이 객관적으로 관찰 될 수 있습니다. [0.67 * totalStaked] (https://latex.codecogs.com/gif.latex?0.67%20*%20totalStaked) 따라서 THORChain은 Rune 소지자가 순환 공급량만큼의 지분을 보유하도록하는 적절한 메커니즘을 만들려고합니다. 이것의 측면이다 : 제안 된`5 %`A 연간 인플레이션은 룬 소유주가 인플레이션 및 검증 기 (Validator)로서의 비용을 절감하도록 장려합니다. 유효성 검사기 세트에 대한 경매 기반 항목을 사용하면 룬 소지자가 서로 경쟁 할 수 없으므로 서로 경쟁 할 수 없습니다. Validator로 승인 된 토큰을 잠 그려면 '14 일'의 본딩 기간. 이렇게하면 장거리 무신론 공격을 막을 수 있습니다. 악성 활동 후 아무런 피해없이 신속한 도주를 시도하는 악성 Validator를 막기 위해 '14 일'의 분리 기간을 둡니다. Validator에게 비용없이 Validator에게 위임을 허용하는 방법 실행 유효성 검사기 인프라. 이를 통해 소수의 Rune 소지자가 네트워크의 보안에 참여할 수 있습니다. THORChain에서 'T0` 창세기 계정을 사용하여 메커니즘 및 UX 스테핑은 간단합니다. 일반적으로 GenAccount는 CLP이지만 'T0'의 경우에는 통화 쌍이 룬 자체이기 때문에 CLP가 필요하지 않습니다. `T0` GenAccount는 현재의 순환 공급, 십진수, 이름과 시세와 같은 Rune에 대한 토큰 정보를 저장합니다. 액티비티 스태커 즈가 유동성 수수료를 벌기 위해 스테이크 대신에 '밸류'에서 스테이크로 블록 리워드를 받는다. 이 트랜잭션 유형은 CLP 스테이징 트랜잭션과 동일한 기본 논리를 사용합니다. | 티커 | `RUNE` | 표시 할 티커 || : --- | : --- | : --- | 이름 | 룬 | 표시 할 이름 공급 | 100,050,000 | '5 %'인플레이션에서 1 년 후의 총 공급. DecimalsReserve | 1.0 | CLP의 분수 예비를 지정하는 매개 변수 (기본값은 1.0) .Owner | Self | 프로토콜 소유 | * 표 : 룬 정보. 총 공급은 Validator Set에 의해 모든 블록을 업데이트했습니다. * 최초의 '100` Validators는`T0`에 연계하여 Validator Set에 진입합니다. 최상위`100 '은 모든 블록을 평가하여 유효성 검사자로 지정됩니다. 스테 킹은 'T0'에 대한 트랜잭션으로 수신 주소가 균형을 따라 스테이징 어레이에 저장됩니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure31.png"width = "350px"height = "233px"/> 그림 : 잠재적 인 Validator가 말뚝을니다. * Staking Array Stakers의 최상위 '100'Validators는 프로토콜을 보호하는 Validator이며 이것은 Validators 배열에서 추적됩니다. 새 유효성 검사기가 '100 번째 유효성 검사기 이상으로 발생하면 유효성 검사기 배열에서 이전 유효성 검사기가 제거되고 새 유효성 검사기가 추가됩니다. 이는 모든 사람이 볼 수 있으며 모든 블록마다 업데이트됩니다. bondPeriod는 발리 데이터가 스테이크 (`14` 일)를 철회하기 전에 블록의 최소량을 지정합니다. Block Rewards는`T0`에 누적됩니다. 블록 보상이 발행되면 tokenData 필드가 업데이트되어 총 Rune 공급이 증가합니다. Staked Validators는 Block Reewards의 분할 몫을 언제든지 철회 할 수 있습니다 (누적 된 보상의 '1/100'). 리워드 인 타이틀먼트는 유효성 검사기 필드에서 추적됩니다. 토큰을 기존의 Validator (또는 Validator가되기 원하는 Staker)에게 위임하는 것은 Stake Array에 이미있는 주소를 지정하는 트랜잭션을 수행하는 Rune 홀더에 의해 수행됩니다. 스테이징 주소 또는 유효하지 않은 주소를 지정하지 않으면 위임자가 아닌 유효성 검사기가됩니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/ 그림 : 룬주 홀더가 Staker에게 위임합니다. The Delegator의 주소는 Staker에 대해 중첩되며 균형과 주소를 저장합니다. Staker는 대표자의 잔액을 쓸 권한이 없지만 총 잔액을 계산합니다. Delegators가 Validator가되기 위해 Staker에 충분한 균형을 추가하면 Staker는 다음 블록으로 이동합니다. 대표단은 철회 할 권리가있다.보상의 그들의 몫은 언제든지 그들의 유효성 검사자의 주소로 누적 된 것에 비례합니다. 대표자는 부모 Validator의 본딩 기간 및 언 바인드 기간에 구속됩니다. Stake와 Rewards를 철회하는 것은 유동성 보유자들이`6.2 절`에서 다루는 CLP의 유동성과 수수료를 철회 할 수 있도록하는 동일한 논리를 통해 이루어진다. 투표 및 발기인 신호는 Validator Signaling 백서에서 다룹니다. ## 기타 기능```*** 이러한 기능은 더 많은 연구가 필요하며 기본 개발 경로에 포함되지 않습니다 *** ### THOR 숯불 이름 서비스 (TNS) 사람이 읽을 수있는 짧은 이름을 * @ satoshi *와 같은 결제 관련 사용자 환경을 개선하기위한 계정은 TNS를 사용할 수 있습니다. 짧은 이름은 MerkleChain에서 고유하고 체인에 저장되며 색인이 생성됩니다. - 사용자는 이름 지정 트랜잭션을 수행하여 계정의 이름을 지정합니다. - 그들의 선택한 이름 앨리스는 MerkleChain과 유일성을 확인하고 저장됩니다. - 하나의 이름을 모든 자산 계정에 사용할 수 있지만 인덱스 또는 시세 표시기를 접미어로 설정하여 'alice.rune`,`alice.btc`,`alice.0`과 같이 지정할 수 있습니다. - RUNE을`alice.btc`에 보내면`alice.rune`에 관계없이 전달됩니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure33.png"width = "350px"height = "157px"/> 그림 : 앨리스의 룬 계정은 alice.rune입니다. * THORChain은 효과적인 할당 및 투자 효율성을 달성 할 수 있도록 이름 서비스를 운영하는 방법을 다시 생각할 수있는 기회를 제공합니다. 이름은 그로부터 최대한의 가치를 이끌어 낼 수있는 당사자에게 재분배되고 각각의 이름은 소유자에게 투자가 될 수 있습니다. TNS의 기본 원리는 Harbinger 세금과 이름을 훔치지 못하도록 경매를하는 하이브리드입니다. "불법 거주자"가 다른 사용자가 구매하고자하는 이름을 소유하고 있다면, 구매자는 특별한 거래에서 "이름 붙이기 (Name Staking)"로 알려진 불법 거주자의 계좌로 룬을 간단히 측설 할 수 있습니다. 불법 점거자가 자신의 구좌에 바이어보다 더 많은 것을 보유하지 않으면, 구매자는 m 블록 후에 무자비하게 그 이름을 구입할 수 있습니다. 불법 행위가 판매를 원하지 않거나 자신의 계좌에 더 많은 것을 보유 할 여력이 없다면 계좌에 이름 스테이크가있는 사람에게 수수료를 지불하기 시작합니다. 불법 점거 자 (squatter)는 가장 높은 입찰자의 지분을 인출함으로써 언제든지 최고 입찰자에게 팔 수 있으며 그 이름은 무분별하게 교환됩니다. 매우 치열한 구매자는 이름을 얻기 위해 인내심을 갖고 있어야하며, 불법 행위자가 지불해야하는 수수료를 높이려면 더 많은 금액을 스테이크해야합니다. 한 계정에 여러 명의 Squatters가있을 수 있습니다. | 계정 소유자 | 이름 Staker | 요금 : --- --- --- --- --- --- --- | 10 룬 | 20 룬 | 20 *! [\ frac {(20-10)} {38 * 0.01}] (https : // latex. codecogs.com/gif.latex?%5Cfrac%7B%2820-10%29%7D%7B38*0.01%7D)every 'm blocks` || 12 Rune | 12 *! [\ frac {(20-10)} {38 * 0.01}] (`https://latex.codecogs.com/gif.latex?%5Cfrac%7B%2820-10%29%7D%7B38*0.01%7D)마다 'm 블록'|| 5 룬 | 5 *! [\ frac {(20-10)} {38 * 0.01}] (https://latex.codecogs.com/gif.latex?%5Cfrac%7B%2820-10%29%7D%7B38*0.01 % R) | 1 [! frac {(20-10)} {38 * 0.01}] (https://latex.codecogs.com/gif.latex?%5Cfrac% 전체 : 38 | Rune |`0.1 Rune`'m blocks`마다 * 표 : Out-Staked 경우 소유자가 요금을 지불합니다. 그들의 지분과 최고 입찰자의 차이에 따라 언제든지 이름을 판매 할 수 있으며 수수료를 내지 않으면 이름을 얻을 수 있습니다. * <img align = "center"src = "https://github.com/thorchain/Resources/blob/master /Whitepapers/THORChain/Images/figure34.png "width ="350px "height ="212px "/> * 그림 : 원하는 이름을 얻기 위해 스테이 킹 이름 *이 방법의 이점은 스쿼터가 항상 그들은 쭈그려 앉고 있지만 적절한 가격에 있습니다. 불법 점거가 실제로 사용되지 않는 계정 인 경우, 결국 계정은 수수료를 통해 비워지고 이름을 얻을 수 있습니다. ### 계정 RecoveryAccount 권한 부여는 [EOS 백서] (https://github.com/EOSIO/Documentation/blob/images/TechnicalWhitePaper.md)에서 처음 설명되었습니다. 계정에 대한보다 세분화 된 통제가 도움이 될 수 있지만 핵심적인 측면은 계정 복구입니다. 계정 복구 프로세스는 주류 채택에 중요합니다. 사용자는 기본 계정에 '복구'와 '보호자'라는 두 가지 유형의 계정을 지정합니다. `Recovery` 계정은 모든 자금과 TNS 이름을 계정으로 이동할 수 있지만 항상 비활성화 된 계정입니다. `Guardian` 계정은`Recovery` 계정을 활성화합니다. 복구 프로세스는 주로 대역 외 통신 및 기존 소셜 또는 트러스트 네트워크에 의존하는 다음과 같습니다. - 사용자가 계정을 생성합니다. - 사용자가 'Guardian'계정 (또는 여러 명)을 지정합니다. '보호자 (Guardian)'에게 통보하고 요청에 서명합니다. - 사용자가 '복구'계정 (또는 여러 계정)을 지정합니다. `복구 '계정에 알림이 전송되고 요청에 서명합니다. 그들은 비활성화됩니다. - 사용자가 개인 키에 액세스 할 수 없습니다. - 사용자는`Guardian`에 접속하여`Reco사용자는 잃어버린 계정에서 복구 된 주소로 서명 한 활성화 된 복구 계정으로 자금을 이동할 수 있습니다. 이 메커니즘은`Guardian`과`Recovery` 계정이 모두 손상되어 안전합니다. `보호자 (Guardian) '계정은 사전 선택된'복구 '계정을 활성화 할 수 있습니다. 또한 'Recovery'계정은 사실 이전에 지정되므로 자금은 원래 소유자가 지정한 주소로만 이동할 수 있습니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure35.png"width = "350px"height = "178px"/> 그림 : Guardian 및 복구 주소는 체인에 저장됩니다. * <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure36.png"width = "350px"height = "205px"/> * 그림 : 보호자가 복구 주소를 활성화합니다. 복구 주소가 잔액을 철회합니다. * ### 다중 서명 계정 다중 서명 계정은 자산 관리의 핵심 부분으로 프로토콜 수준에서 지원됩니다. 계정 소유자는 특수 거래에 외부 계정을 추가하기 만하면됩니다. 추가 된 모든 거래는 모든 당사자가 서명하도록 요구합니다. 서명은 계정에 집계되고 최종 당사자는 트랜잭션을 수행합니다. 트랜잭션이 수행되면 서명이 지워집니다. 기본값은 n의 n이지만 이것은 당사자가 언제든지 쉽게 변경할 수 있습니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure37.png"width = "350px"height = "155px"/> 그림 : THORChain multi-sig. * ### Smart contractsTHORChain은 생태계를 향상시키기 위해 현명한 계약을 지원할 수 있지만 이는 기본 개발 경로에 포함되지 않습니다. 온 - 체인 (on-chain) 거버넌스에 통합 될 가능성이 높습니다. 프로토콜 전체에 도움이되는 잠재적 인 스마트 계약은 네이티브 온 체인 명령으로 대신 추가해야합니다. THORChain은 dApp 플랫폼으로 구축하려는 것이 아닙니다. 오히려 그것은 디지털 자산과 이러한 자산의 거래에 중점을 둡니다. ### Additional On-Chain CommandsTHORChain은 프로토콜로 하드 코딩 된 경량 메소드 인 on-chain 명령을 사용하며 트랜잭션에 의해 호출됩니다. 현명한 계약과 비교할 때 이러한 네이티브 온 체인 명령에는 가상 시스템 지원이 필요하지 않으며 기본 프로토콜의 일부입니다. 똑똑한 계약은 일반적이고 바이트 코드로 컴파일해야하지만 고급 트랜잭션 출력 / 입력과 같은 기능을합니다. 하나가 실행될 때마다 스크립트 상태에 따라 계정의 상태가 업데이트됩니다. On-chain 명령은 표준화 된 방법으로 프로토콜에 내장되어 있습니다. 그러나 일단 표준이 합의되면 온 - 체인 (on-chain) 거버넌스를 통해 프로토콜 계층에 추가됩니다. - 보안 토큰 - Stablecoins - 수집품 (ERC-721) - 신원 (ERC-725, 735) - 경상 수지 - 계정 허가 - 에스크로 ### StableCoins THORChain의 매크로 비전 완전 신뢰없는 구조로 구축 된 유동성있는 지불 네트워크를 만드는 것입니다. 주류 채택을위한 필수 기능은 USD, YEN, EURO 및 AUD와 같은 기존의 화폐 통화에 고정되어있는 안정적인 동전입니다. 이를 달성하기위한 첫 번째 방법은 기존의 안정된 동전을 단순히 표시하는 것인데 반해, 두 번째는 플랫폼에서 안정적인 동전의 개발을 지원하는 것입니다. `§ 8 '의 교량이 지어지면 자연히 쉽게 될 것입니다. THORChain은 변수 공급 토큰과 CLP 및 Validator Set 전체를 사용하여 감사 가능한 공급 물과 담보물을 가진 StableCoin을 만드는 데 필요한 모든 기능을 갖추고 있습니다. 다음은 프로세스입니다. - 토큰 체인 tUSD는 유효성 검사기 집합에 의해 생성됩니다. 가변적 인 공급원 인`Rune : tUSD` CLP가 생성되며, Validators로부터 '2/3'서명이 필요합니다. - 각 라운드에서 Validators는 Rune이 가치가있는 가격 $을 제안합니다. 이들은 가능한 모든 수단을 통해이를 추론 할 수 있으며, 대부분 Rune의 외부 교환 대기업에서 API를 읽음으로써 가능할 수 있습니다. 유효성 검사기는 Bitcoin의 외부 거래 가격 결정을보고 Rune : tBTC 가격 피드를 통해 Rune 가격으로 변환하여 Rune 가격을 지정할 수도 있습니다. - 각 라운드 'n + 1'에서 지명 된 가격의 중앙값이 블록에 저장됩니다. 이상 치는 빈약 한 가격 지명을 처벌하기 위해 깎는 규칙을 호출 할 수 있습니다. - Rune 가격이 변동함에 따라 CLP에서 'tUSD'공급은 Validators에 의해 부정적으로 변경됩니다. 예를 들어 Rune 가격이 '2 %'하락하면 tUSD 공급이 '4 %'증가합니다. 이것은`tUSD`를 부풀게하고 싸게 만듭니다. - 자기 관심이있는 중개인은 자산으로 뒷받침되는 'tUSD'가 '1 : 1'로 돌아올 때까지 싼 'tUSD'를 사기 위해 룬을 보낸다. 또한 유동성 요금은 CLP의 담보권을 증가시켜 볼륨과 미끄러짐을 줄입니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure38.png"width = "900px"height = "246px"/> 그림 : 체인 식 StableCoins에 담보 * *이 프로세스는 다른 모든 커런cy는 매우 간단합니다. 룬의 외부 가격은 (피아트 통화) 설정되면, 다음 프로토콜은 의도적으로 어떤 가격 불균형을 복원 할 이기적인 방식으로 행동하는 제삼자를 유치하기 위해 통화 공급에 영향을 미치는으로 차익 기회를 만듭니다. 가격 지정에 Validator Set 전체 참여를 요구함으로써 StableCoin의 가격은 전체 프로토콜 자체와 동일한 보증에 의존 할 수 있습니다. 가격 결정 / 공급 피드백 루프는 댐핑 및 가격 민감도를 줄이기 위해 수정할 수 있습니다. ### 토큰 바구니 & 인덱스 THORChain은 CLP에서 표현되는 하나의 토큰 이상이 될 수 있습니다. CLP 스크립트와 신뢰할 수없는 가격 피드를 결합하여 토큰 바구니와 인덱스를 생성하고 하나의 자산으로 나타낼 수 있습니다. 이를 통해 사용자와 거래자는 하나의 토큰을 가지고 그 토큰의 가격이 다른 자산을 신뢰할 수 없게 나타낼 수 있습니다. `TKN1`,`TKN2` 및`TKN3`을 나타내는 새로운 tokenChain`TKNIndex`가 생성 될 수 있습니다. 여기서`TKNIndex`에 대한`TokenData`와`CLPData`는 인덱스 된 자산의 CLP에 링크됩니다. 은`TKNIndex` CLP는 TKNIndex``의 가격이 이렇게 링크 된 자산의 대표 있도록 다른 모든 CLPs에 유동성을 포함하는 결합된다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure39.png"width = "350px"height = "298px"/> 그림 : Token Baskets * ### AnonymityTHORChain은 연결 가능성을 방지하기 위해 계정을 다시 생성 할 수 있도록 ZK 증명을 구현할 수 있습니다. 이것은 Komodo와 유사한 구현이며 알려진 기술을 사용하여 만들어집니다. 토큰은 하나의 트랜잭션에서 파괴 된 다음 새로운 코인베이스 트랜잭션에서 신뢰없이 생성됩니다. 시간 분석에서 신원을 추적하지 못하도록 Alice는 계정의 재발 생까지 블록 높이 지연을 지정할 수 있습니다. 일시적으로 사라지는 토큰을 가진 즉시 나타나는 토큰을 식별하는 시간 분석을 방지합니다. 가변 대기 시간을 설정하여 잡음을 증가시킬 수 있습니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure40.png"width = " 350px "높이 ="223px "/> * 그림 :. 익명 * ### 4.4 프로토콜 ABIFIX 4.4은 걸쳐 표준화하고 효율적인 방법으로 표시, 주문 및 실행 등의 거래를 배치 트레이딩 데스크를 위해 구축 된 해외 정보 교환 프로토콜입니다 FIX 네트워크. 표준 전자 거래 프로토콜로 채택되었으며 THORChain은 FIX 4.4 호환성을 구축하여 유동성과 기관 거래자 및 투자자의 접근성을 높일 계획입니다. 다음과 같은 메시지 유형이 일반적으로 FIX 4.4에서 사용된다 : - 관심 -의 표시를 견적 요청 -는 응답 - Quote- 새로운 명령 - 실행 리포트 - 할당 명령 견적 - 할당 보고서 - 무역 캡처 리포트 - 응용 프로그램 Blockchain 인터페이스 (ABI)는 프로토콜에 다리를하고 유동성 니즈와 주문 유형에 따라 레이어 1 또는 레이어 2에서 주문을 생성 할 수 있습니다. <img align = "center"src = "https://github.com/thorchain/Resources/blob/master/Whitepapers/THORChain/Images/figure41.png"width = "350px"height = "400px"/> 그림 : 4.4 구현 제안을 FIX * ## ConclusionTHORChain 오늘의 최고의 중앙 집중식 교류와 기능 패리티를 달성하기 위해 프로토콜 수준의 거래 기능을 가진 번개 빠른 분산 교환입니다. 모든 것은 완전한 자기 - 주권 적 자산 관리를 가지고있다. THORChain은 신속한 온 - 체인 거래 경험, 온 - 체인 연속 유동성 및 교환 및 지갑 개발자를위한 올바른 인센티브 경제학을 통해 기존의 분산 형 Exchange의 근본적인 문제를 해결합니다 .THORChain은 새로운 종류의 분산 된 거래소 및 거래 네트워크를 위해 만들어지며 급속히 증가 할 것입니다 crypto-currency 자산으로 거래의 유용성. ## 참고 문헌 - Anon. (n.d.). 브레인 월렛. [온라인]. https://en.bitcoin.it/wiki/Brainwallet.- Ethereum에서 다운로드 할 수 있습니다. (n.d.). 이해 관계 증명 전 ETH 발급 줄이기. 문제 # 186 / ethereum / EIPsGitHub. [온라인]. https://github.com/ethereum/EIPs/issues/186.- Interchain Foundation에서 다운로드 할 수 있습니다. (2017). 컨센서스 비교 : Casper vs. Tendermint - Cosmos BlogCosmos 블로그, Cosmos Blog. [온라인]. 이용 가능한 장소 : https://blog.cosmos.network/consensus-compare-casper-vs-tendermint-6df154ad56ae.- 왕, R. (2018). Binance 검토 - Binance ExchangeBitDegree 자습서, BitDegree 자습서의 전체 개요. [온라인]. https://www.bitdegree.org/tutorials/binance-review/.- Anon에서 다운로드 할 수 있습니다. (n.d.). POA 네트워크. [온라인]. 이용 가능 : https://poa.network/.- Posner, E. (2014). 이차 방위 표지. [온라인]. 이용 가능 : http://ericposner.com/quadratic-voting/.- Unchained, C. (2018). 코스모스 검사기 경제 - BlockchainsCosmos 블로그, 코스모스 블로그의 새로운 시대로 옛 경제 시스템을 연결. [온라인]. 구매 가능 : https://blog.cosmos.network/economics-of-proof-of-stake-bridging-the-economic-system-of-old-into-the-new-age-of-blockchains-3f17824e91db.- Unchained, C. (2018). 제안 된 코스모스 요금 징표 - 코드 네임 광자 - 텐더 미트 - 중형 미디어, 증강 휴머nity. [온라인]. 다운로드 가능 : https://medium.com/tendermint/proposed-cosmos-fee-token-codename-photon-e0927daf5c4c.- 연결되지 않음, C. (2018). 상호 운용성 기술 - Ethereum Peg ZoneCosmos 블로그, Cosmos 블로그 소개 [온라인]. 이용 가능 : https://blog.cosmos.network/the-internet-of-blockchains-how-cosmos-does-interoperability-starting-with-the-herehereum-peg-zone-8744d4d2bc3f.- Anon. (n.d.). 텐드민트 란 무엇입니까? [온라인]. https://tendermint.readthedocs.io/en/master/introduction.html.-bitfly.at에서 다운로드 할 수 있습니다. (n.d.). Miner Block Gas Limit 총 에테르 공급의 투표 회귀. [온라인]. https://www.etherchain.org/tools/gasLimitVoting에서 다운로드 할 수 있습니다.
